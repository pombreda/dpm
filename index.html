
<!DOCTYPE html>
<html>
  <head>
    <title>dpm</title>
    <meta charset='utf-8'>
    <script src='static/slides.js'></script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>
      
      <article>
        <h1>dpm</h1>
        <h3>A dependency package manager for the Go language.</h3>
        <h3>23 May 2013</h3>
        
          <div class="presenter">
            
  
  <p>
    Casey Marshall
  </p>
  

  
  <p>
    Software Flâneur
  </p>
  

          </div>
        
          <div class="presenter">
            
  
  <p>
    
  </p>
  

          </div>
        
      </article>
      
  
  
      <article>
      
        <h3>Package Managers</h3>
        
  
  <p>
    &#34;A sufficiently successful software system evolves its own special unique snowflake of a package management system.&#34;
  </p>
  

  
  <p>
    Operating systems: rpm, deb, ports, brew
  </p>
  

  
  <p>
    Programming languages: pip, gem, npm, cpan, cabal, maven
  </p>
  

  
  <p>
    Applications: Mozilla Firefox/T-Bird, Google Chrome, Eclipse
  </p>
  

  
  <p>
    Don&#39;t get me wrong, package management and provisioning is great. But also, complicated.
  </p>
  

  <ul>
  
    <li>Where are packages stored? Hosted? Failover? Reliability? Uptime?</li>
  
    <li>What if I want to package something for an OS, that has its own package management?</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Go philosophy</h3>
        
  
  <p>
    There is this general reluctance to rebuild the same complicated solutions.
  </p>
  

  <ul>
  
    <li>Templates</li>
  
    <li>Dynamic libraries</li>
  
    <li>Package managers</li>
  
  </ul>

  
  <p>
    Question all the &#34;harmful things&#34; that have become accepted as status quo.
<br>

    This reluctance to follow past compromises, is why Go can be so refreshing.
  </p>
  

  
  <p>
    DVCS-based &#34;go get&#34; package dependency management works for well-managed projects that follow a gentleman&#39;s agreement.
  </p>
  

  
  <p>
    But for a larger, longer-term, mission-critical project you build a business on, that might not be good enough. In that case,
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Go manage your project</h3>
        
<div class="image">
  <img src="img/angry-baby.jpg">
</div>

  
  <p>
    You are responsible for the third-party project dependencies you chose for that Kickstarter project. Or, <a href="http://forums.thedailywtf.com/forums/t/27755.aspx?PageIndex=1" target="_blank">you confused a gopher for your mama</a>.
  </p>
  

  
  <p>
    (Wow, that was specific!)
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Responsible for what?</h3>
        
  
  <p>
    Relocating &#34;connected&#34; packages obtained from &#34;go get&#34;...
<br>

    To a &#34;disconnected&#34; local package namespace?
<br>

    Or your own GitHub forks?
<br>

    What about multiple DVCS for third-party deps?
  </p>
  

  
  <p>
    Tracking upstream changes for the above.
  </p>
  

  
  <p>
    Re-creating the same third-party package state for other developers on your team.
<br>

    Or for a Linux distribution package?
  </p>
  

  
  <p>
    Providing attribution for all your third-party licenses.
  </p>
  

  
  <p>
    Now be honest, are you really managing your Go package dependencies as well as you should?
<br>

    If you are, I bet you are very busy, or you have some awesome tools.
<br>

    Until you share them, I propose...
  </p>
  

      
      </article>
  
  
  
      <article>
      
        <h3>The Go Dependency Package Manager (dpm)</h3>
        
  
  <p>
    Represent a project&#39;s package dependencies as a YAML file.
  </p>
  

  <ul>
  
    <li>What do I need to build this project?</li>
  
    <li>Where do I get it?</li>
  
    <li>What revision do I get?</li>
  
    <li>How should I update it? <i>Should</i> I update it?</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Getting Started with dpm</h3>
        
  
  <div class="code"><pre>dpm import</pre></div>
  

  <ul>
  
    <li>Parses your project source files for package dependencies.</li>
  
    <li>Creates a starting point <code>dpm.yml</code> file.</li>
  
    <li>Check out dependencies into a project-local <code>$GOPATH</code>, <code>.dpm</code>.</li>
  
    <li>Generate a profile script (similar to virtualenv &#39;activate&#39;) to set <code>$GOPATH</code>.</li>
  
  </ul>

  
  <p>
    <code>dpm.yml</code> example:
  </p>
  

  
  <div class="code"><pre>---
name: hockeypuck
pkg: launchpad.net/hockeypuck
rev: HEAD
deps:
 - pkg: github.com/cmars/conflux
   rev: 0c3ae5
 - pkg: code.google.com/p/go.crypto/openpgp
   rev: 1.1</pre></div>
  

      
      </article>
  
  
  
      <article>
      
        <h3>Managing Packages</h3>
        
  
  <div class="code"><pre>dpm pin &lt;package name&gt; [-rev &lt;rev&gt;]</pre></div>
  

  <ul>
  
    <li>Revision identifier using DVCS-specific identifier (tip, HEAD, branch, 0c3ae5, rel1.1, etc.)</li>
  
  </ul>

  
  <div class="code"><pre>dpm pull [-force]</pre></div>
  

  <ul>
  
    <li>Update project-local <code>$GOPATH</code> according to rules in dpm.yml. Option to force overwrite or exit if there are locally modified working copies.</li>
  
  </ul>

  
  <div class="code"><pre>dpm relocate &lt;old upstream pkg&gt; &lt;new upstream pkg&gt; [-rev &lt;new upstream rev&gt;]</pre></div>
  

  <ul>
  
    <li>Relocate the upstream package. Use this to point at a different upstream repository. Useful when forking an upstream project.</li>
  
  </ul>

  
  <div class="code"><pre>dpm status</pre></div>
  

  <ul>
  
    <li>Display the current state (revision, etc.) of all package dependencies.</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Scope</h3>
        
  
  <p>
    dpm is not &#34;Maven for Go&#34;.
  </p>
  

  
  <p>
    dpm is more like virtualenv, it just manages a standalone, project-specific, repeatable <code>$GOPATH</code> for you. That&#39;s it.
  </p>
  

  
  <p>
    If you want more, write tools that operate on the <code>$GOPATH</code>. Some ideas:
  </p>
  

  <ul>
  
    <li>Operating system packaging tools. Build <code>.deb</code> or <code>.rpm</code> packages with repeatable results.</li>
  
    <li>Compile all the package dependency LICENSE files into a <code>debian/copyright</code> file.</li>
  
    <li>Generate source and binary distribution tarballs, like <code>python setup.py sdist</code> or <code>bdist</code>.</li>
  
    <li>Fork a package dependency and relocate in one step. Perhaps create a Github project with their API?</li>
  
    <li>Generate cross-compiled <code>bdist</code> tarballs.</li>
  
  </ul>

      
      </article>
  
  
  
      <article>
      
        <h3>Request for Comments</h3>
        
  
  <p>
    I haven&#39;t started development yet. I&#39;d like to gather feedback from the Go community before I get too far in the weeds.
  </p>
  

  
  <p>
    What do you think?
  </p>
  

  
  <p>
    What would you add?
  </p>
  

  
  <p>
    What would you take away?
  </p>
  

      
      </article>
  
  

      <article>
        <h3>Thank you</h1>
        
          <div class="presenter">
            
  
  <p>
    Casey Marshall
  </p>
  

  
  <p>
    Software Flâneur
  </p>
  
<p class="link"><a href="mailto:casey.marshall@gmail.com" target="_blank">casey.marshall@gmail.com</a></p><p class="link"><a href="https://github.com/cmars/dpm" target="_blank">https://github.com/cmars/dpm</a></p>
          </div>
        
          <div class="presenter">
            
  
  <p>
    
  </p>
  

          </div>
        
      </article>

  </body>
  
</html>
